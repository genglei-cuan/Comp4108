Reading analysis of StackGuard: Automatic Adaptive Detection and Prevention of Buffer-Overflow Attacks

The paper by Cowan et al. discussed the widespread buffer overflow vulnerability, one of the earliest exploits (still prevalent today), and a solution to protect the system from it. Two solutions were introduced in the paper: StackGuard and MemGuard.

StackGuard is a compiler extension that adds canaries, simply a known byte value, between the local variables of the current stack frame and the return address. Buffer overflows normally exploit the program by overwriting the frame's return address with an address that points to the injected "bad code", but with StackGuard the canary byte is overwritten when the attacker goes to overwrite the return address. When this occurs, the program sees that the canary byte has changed, resulting in the program terminating because the program doesn't know how much memory corruption the attacker has achieved. Overall, the canary method of preventing buffer overflow attacks results in an extra overhead of 6%, very negligible for the added security benefit.

The second method of protecting programs from buffer overflow attacks is MemGuard. MemGuard is a compiler extension that write protects the return addresses of the stack frames. Because buffer overflow exploits rely on changing the return address of the stack frame, this method successfully thwarts those attacks. Unfortunately, the main downside to MemGuard is it's performance overhead. From the analysis done by Cowan et al. it is shown that MemGuard has an upper bound of 1000% overhead to the run time of a program.

The authors evaluate their StackGuard and MemGuard solutions by taking known buffer overflow exploits of various programs and seeing if StackGuard and MemGuard can successfully prevent the buffer overflow attack. In all stack-based exploit cases both StackGuard and MemGuard are able to halt the program when the buffer overflow attack occurs. In a few evaluations, the buffer overflow attacks targeted memory on the heap or addresses in local variables, specifically not the stack frame return address. In this case MemGuard and StackGuard was not able to detect the buffer overflow exploit.

Adding StackGuard and MemGuard to a system's programs consists of compiling the programs with the StackGuard compiler extensions. Once that's done, detecting if StackGuard is enabled only can happen when the program is maliciously manipulated. ie. a buffer overflow attack.

Overall, the paper by Cowan et al. was an interesting read as it provided an intuitive solution to preventing all past and future bugs in code that can be leveraged into buffer overflow attacks. The lengthy paper was easy to digest and left me with the knowledge of canaries and write protected memory for preventing buffer overflow attacks. In the end, I was surprised with the overhead that MemGuard came with. The authors did make the sound argument that the extreme overhead of 1000% was worth the added protection for programs that run as SUID root, and that those programs most of the time are not run that often.
